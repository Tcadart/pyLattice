

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>src.Cell &mdash; pyLattice 1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=f2a433a1"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            pyLattice
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">pyLattice</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">src.Cell</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for src.Cell</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Cell.py</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">colorama</span> <span class="kn">import</span> <span class="n">Fore</span><span class="p">,</span> <span class="n">Style</span>

<span class="kn">from</span> <span class="nn">Beam</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">Geometry_Lattice</span> <span class="kn">import</span> <span class="n">Lattice_geometry</span>

<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">coo_matrix</span>


<div class="viewcode-block" id="Cell">
<a class="viewcode-back" href="../../src.html#src.Cell.Cell">[docs]</a>
<span class="k">class</span> <span class="nc">Cell</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Define Cell data for lattice structure</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">posCell</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">initialCellSize</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">startCellPos</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">geom_types</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
                 <span class="n">Radius</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">gradRadius</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">gradDim</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">gradMat</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">uncertaintyNode</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize a Cell with its dimensions and position</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        posCell: list</span>
<span class="sd">            Position of the cell in the lattice</span>
<span class="sd">        initialCellSize: list</span>
<span class="sd">            Initial size of the cell</span>
<span class="sd">        startCellPos: list</span>
<span class="sd">            Position of the start of the cell</span>
<span class="sd">        geom_types: int</span>
<span class="sd">            Type of lattice geometry</span>
<span class="sd">        radii: float</span>
<span class="sd">            Base radius of the beam</span>
<span class="sd">        gradRadius: list</span>
<span class="sd">            Gradient of the radius</span>
<span class="sd">        gradDim: list</span>
<span class="sd">            Gradient of the dimensions</span>
<span class="sd">        gradMat: list</span>
<span class="sd">            Gradient of the material</span>
<span class="sd">        uncertaintyNode: float</span>
<span class="sd">            Standard deviation for adding uncertainty to node coordinates. Defaults to 0.0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">originalCellGeom</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">originalTags</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">centerPoint</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_beamMaterial</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cellSize</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">posCell</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">posCell</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coordinateCell</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">startCellPos</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">geom_types</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">geom_types</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">Radius</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matB</span><span class="p">:</span> <span class="n">Optional</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># B matrix (Coupling matrix)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">uncertaintyNode</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">uncertaintyNode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gradRadius</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="n">gradRadius</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gradMat</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="n">gradMat</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gradDim</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="n">gradDim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">neighbourCells</span><span class="p">:</span> <span class="n">Optional</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">defineOriginalTags</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generateCellProperties</span><span class="p">(</span><span class="n">initialCellSize</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Cell(Coordinates:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinateCell</span><span class="si">}</span><span class="s2">, Size: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cellSize</span><span class="si">}</span><span class="s2">, Index:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="si">}</span><span class="s2">)&quot;</span>

<div class="viewcode-block" id="Cell.generateCellProperties">
<a class="viewcode-back" href="../../src.html#src.Cell.Cell.generateCellProperties">[docs]</a>
    <span class="k">def</span> <span class="nf">generateCellProperties</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initialCellSize</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a cell object with beams and nodes based on the lattice type and radius.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        initialCellSize: list</span>
<span class="sd">            Initial size of the cell without modification</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idxCell</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">rad</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">rad</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">idxCell</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">getBeamMaterial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gradMat</span><span class="p">)</span>
                    <span class="n">beamRadius</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getBeamRadius</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gradRadius</span><span class="p">,</span> <span class="n">rad</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">getCellSize</span><span class="p">(</span><span class="n">initialCellSize</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gradDim</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">generateBeamsInCell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geom_types</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinateCell</span><span class="p">,</span> <span class="n">beamRadius</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">getCellCenter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinateCell</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">hybridRadius</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getBeamRadius</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gradRadius</span><span class="p">,</span> <span class="n">rad</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">generateBeamsInCell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geom_types</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinateCell</span><span class="p">,</span> <span class="n">hybridRadius</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
                <span class="n">idxCell</span> <span class="o">+=</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="Cell.defineOriginalTags">
<a class="viewcode-back" href="../../src.html#src.Cell.Cell.defineOriginalTags">[docs]</a>
    <span class="k">def</span> <span class="nf">defineOriginalTags</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define original tags and cell geometry based on the lattice type and radius.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        geom_types: list[int]</span>
<span class="sd">            List of lattice types</span>
<span class="sd">        radii: list[float]</span>
<span class="sd">            List of beam radii</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">originalTags</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">1001</span><span class="p">,</span> <span class="mi">1002</span><span class="p">,</span> <span class="mi">1003</span><span class="p">,</span> <span class="mi">1004</span><span class="p">,</span> <span class="mi">1005</span><span class="p">,</span> <span class="mi">1006</span><span class="p">,</span> <span class="mi">1007</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">originalCellGeom</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">16</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">originalTags</span> <span class="o">=</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">101</span><span class="p">,</span> <span class="mi">102</span><span class="p">,</span> <span class="mi">103</span><span class="p">,</span> <span class="mi">104</span><span class="p">,</span> <span class="mi">105</span><span class="p">,</span> <span class="mi">106</span><span class="p">,</span> <span class="mi">107</span><span class="p">,</span> <span class="mi">108</span><span class="p">,</span> <span class="mi">109</span><span class="p">,</span> <span class="mi">110</span><span class="p">,</span> <span class="mi">111</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">originalCellGeom</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">19</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">originalTags</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">15</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">originalCellGeom</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom_types</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">16</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">originalTags</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">1001</span><span class="p">,</span> <span class="mi">1002</span><span class="p">,</span> <span class="mi">1003</span><span class="p">,</span> <span class="mi">1004</span><span class="p">,</span> <span class="mi">1005</span><span class="p">,</span> <span class="mi">1006</span><span class="p">,</span> <span class="mi">1007</span><span class="p">,</span>
                                     <span class="mi">100</span><span class="p">,</span> <span class="mi">101</span><span class="p">,</span> <span class="mi">102</span><span class="p">,</span> <span class="mi">103</span><span class="p">,</span> <span class="mi">104</span><span class="p">,</span> <span class="mi">105</span><span class="p">,</span> <span class="mi">106</span><span class="p">,</span> <span class="mi">107</span><span class="p">,</span> <span class="mi">108</span><span class="p">,</span> <span class="mi">109</span><span class="p">,</span> <span class="mi">110</span><span class="p">,</span> <span class="mi">111</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">originalCellGeom</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                                         <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Lattice type not recognized&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">originalTags</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">1001</span><span class="p">,</span> <span class="mi">1002</span><span class="p">,</span> <span class="mi">1003</span><span class="p">,</span> <span class="mi">1004</span><span class="p">,</span> <span class="mi">1005</span><span class="p">,</span> <span class="mi">1006</span><span class="p">,</span> <span class="mi">1007</span><span class="p">,</span>
                                 <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span>
                                 <span class="mi">100</span><span class="p">,</span> <span class="mi">101</span><span class="p">,</span> <span class="mi">102</span><span class="p">,</span> <span class="mi">103</span><span class="p">,</span> <span class="mi">104</span><span class="p">,</span> <span class="mi">105</span><span class="p">,</span> <span class="mi">106</span><span class="p">,</span> <span class="mi">107</span><span class="p">,</span> <span class="mi">108</span><span class="p">,</span> <span class="mi">109</span><span class="p">,</span> <span class="mi">110</span><span class="p">,</span> <span class="mi">111</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">originalCellGeom</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                                     <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
                                     <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span></div>


<div class="viewcode-block" id="Cell.generateBeamsInCell">
<a class="viewcode-back" href="../../src.html#src.Cell.Cell.generateBeamsInCell">[docs]</a>
    <span class="k">def</span> <span class="nf">generateBeamsInCell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">latticeType</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">startCellPos</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">beamRadius</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">beamType</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate beams and nodes using a given lattice type and parameters.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        geom_types: int</span>
<span class="sd">            Type of lattice geometry</span>
<span class="sd">        startCellPos: list</span>
<span class="sd">            Position of the start of the cell</span>
<span class="sd">        beamType: int</span>
<span class="sd">            Type of beam</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pointDict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">Lattice_geometry</span><span class="p">(</span><span class="n">latticeType</span><span class="p">):</span>
            <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">z1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">z2</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">z1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">pointDict</span><span class="p">:</span>
                <span class="n">point1</span> <span class="o">=</span> <span class="n">pointDict</span><span class="p">[(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">z1</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">point1</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">x1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellSize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">startCellPos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellSize</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">startCellPos</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                               <span class="n">z1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellSize</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">startCellPos</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">uncertaintyNode</span><span class="p">)</span>
                <span class="n">pointDict</span><span class="p">[(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">z1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">point1</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">z2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">pointDict</span><span class="p">:</span>
                <span class="n">point2</span> <span class="o">=</span> <span class="n">pointDict</span><span class="p">[(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">z2</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">point2</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">x2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellSize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">startCellPos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellSize</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">startCellPos</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                               <span class="n">z2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellSize</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">startCellPos</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">uncertaintyNode</span><span class="p">)</span>
                <span class="n">pointDict</span><span class="p">[(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">z2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">point2</span>
            <span class="n">beam</span> <span class="o">=</span> <span class="n">Beam</span><span class="p">(</span><span class="n">point1</span><span class="p">,</span> <span class="n">point2</span><span class="p">,</span> <span class="n">beamRadius</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_beamMaterial</span><span class="p">,</span> <span class="n">beamType</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">beams</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">beam</span><span class="p">)</span></div>


<div class="viewcode-block" id="Cell.getBeamMaterial">
<a class="viewcode-back" href="../../src.html#src.Cell.Cell.getBeamMaterial">[docs]</a>
    <span class="k">def</span> <span class="nf">getBeamMaterial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gradMat</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the material of the beam based on the gradient and position.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        gradMat: list</span>
<span class="sd">            Gradient of the material</span>

<span class="sd">        Returns:</span>
<span class="sd">        ---------</span>
<span class="sd">        materialType: int</span>
<span class="sd">            Material index of the beam</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_beamMaterial</span> <span class="o">=</span> <span class="n">gradMat</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">posCell</span><span class="p">[</span><span class="mi">2</span><span class="p">]][</span><span class="bp">self</span><span class="o">.</span><span class="n">posCell</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="bp">self</span><span class="o">.</span><span class="n">posCell</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span></div>


<div class="viewcode-block" id="Cell.getBeamRadius">
<a class="viewcode-back" href="../../src.html#src.Cell.Cell.getBeamRadius">[docs]</a>
    <span class="k">def</span> <span class="nf">getBeamRadius</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gradRadius</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">BaseRadius</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate and return the beam radius</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        gradRadius: list</span>
<span class="sd">            Gradient of the radius</span>
<span class="sd">        BaseRadius: float</span>
<span class="sd">            Base radius of the beam</span>

<span class="sd">        Returns:</span>
<span class="sd">        ---------</span>
<span class="sd">        actualBeamRadius: float</span>
<span class="sd">            Calculated beam radius</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">beamRadius</span> <span class="o">=</span> <span class="p">(</span><span class="n">BaseRadius</span> <span class="o">*</span> <span class="n">gradRadius</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">posCell</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">gradRadius</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">posCell</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span>
                      <span class="n">gradRadius</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">posCell</span><span class="p">[</span><span class="mi">2</span><span class="p">]][</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">beamRadius</span></div>


<div class="viewcode-block" id="Cell.getCellSize">
<a class="viewcode-back" href="../../src.html#src.Cell.Cell.getCellSize">[docs]</a>
    <span class="k">def</span> <span class="nf">getCellSize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initialCellSize</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">gradDim</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate and return the cell size</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        initialCellSize: 3-array</span>
<span class="sd">            Dimension of the initial cell without modification</span>
<span class="sd">        gradDim:</span>

<span class="sd">        Returns:</span>
<span class="sd">        ---------</span>
<span class="sd">        cellSize : float</span>
<span class="sd">            Calculated beam radius</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cellSize</span> <span class="o">=</span> <span class="p">[</span><span class="n">initial_size</span> <span class="o">*</span> <span class="n">gradDim</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">initial_size</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span> <span class="ow">in</span>
                         <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">initialCellSize</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">posCell</span><span class="p">))]</span></div>


<div class="viewcode-block" id="Cell.getCellCenter">
<a class="viewcode-back" href="../../src.html#src.Cell.Cell.getCellCenter">[docs]</a>
    <span class="k">def</span> <span class="nf">getCellCenter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">startCellPos</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the center point of the cell</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">centerPoint</span> <span class="o">=</span> <span class="p">[</span><span class="n">startCellPos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellSize</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span></div>


<div class="viewcode-block" id="Cell.getAllPoints">
<a class="viewcode-back" href="../../src.html#src.Cell.Cell.getAllPoints">[docs]</a>
    <span class="k">def</span> <span class="nf">getAllPoints</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine a list of points in cell</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pointList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">point</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">pointList</span><span class="p">:</span>
                    <span class="n">pointList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pointList</span></div>


<div class="viewcode-block" id="Cell.removeBeam">
<a class="viewcode-back" href="../../src.html#src.Cell.Cell.removeBeam">[docs]</a>
    <span class="k">def</span> <span class="nf">removeBeam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beamToDelete</span><span class="p">:</span> <span class="s2">&quot;Beam&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes a beam from the lattice</span>

<span class="sd">        Parameters:</span>
<span class="sd">        ------------</span>
<span class="sd">        beamToDelete: beam Object</span>
<span class="sd">            Beam to remove</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">beams</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">beamToDelete</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Beam not found in the list&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Cell.addBeam">
<a class="viewcode-back" href="../../src.html#src.Cell.Cell.addBeam">[docs]</a>
    <span class="k">def</span> <span class="nf">addBeam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beamToAdd</span><span class="p">:</span> <span class="s2">&quot;Beam&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adding beam to cell</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">beamToAdd</span><span class="p">,</span> <span class="n">Beam</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">beams</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">beamToAdd</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">beamToAdd</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="n">beamToAdd</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">beams</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">beam</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid beam type&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Cell.getPointOnSurface">
<a class="viewcode-back" href="../../src.html#src.Cell.Cell.getPointOnSurface">[docs]</a>
    <span class="k">def</span> <span class="nf">getPointOnSurface</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">surfaceName</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the points on the surface specified in the global reference frame.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        surfaceName: str</span>
<span class="sd">            Name of the surface. Choose from &#39;Xmin&#39;, &#39;Xmax&#39;, &#39;Ymin&#39;, &#39;Ymax&#39;, &#39;Zmin&#39;, &#39;Zmax&#39;, &#39;Xmid&#39;, &#39;Ymid&#39;, &#39;Zmid&#39;.</span>
<span class="sd">            If &#39;Xmid&#39;, &#39;Ymid&#39;, or &#39;Zmid&#39; is specified, it returns the points at the bottom of the cell</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        list</span>
<span class="sd">           List of points on the specified surface.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">boundaryBox</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getCellBoundaryBox</span><span class="p">()</span>
        <span class="n">surface_map</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;Xmin&quot;</span><span class="p">:</span> <span class="n">boundaryBox</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="s2">&quot;Xmax&quot;</span><span class="p">:</span> <span class="n">boundaryBox</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="s2">&quot;Ymin&quot;</span><span class="p">:</span> <span class="n">boundaryBox</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
            <span class="s2">&quot;Ymax&quot;</span><span class="p">:</span> <span class="n">boundaryBox</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
            <span class="s2">&quot;Zmin&quot;</span><span class="p">:</span> <span class="n">boundaryBox</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
            <span class="s2">&quot;Zmax&quot;</span><span class="p">:</span> <span class="n">boundaryBox</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span>
            <span class="s2">&quot;Xmid&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinateCell</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="s2">&quot;Ymid&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinateCell</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="s2">&quot;Zmid&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinateCell</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="p">}</span>

        <span class="n">coord_index</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;Xmin&quot;</span><span class="p">:</span> <span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;Xmax&quot;</span><span class="p">:</span> <span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;Xmid&quot;</span><span class="p">:</span> <span class="s2">&quot;x&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Ymin&quot;</span><span class="p">:</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;Ymax&quot;</span><span class="p">:</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;Ymid&quot;</span><span class="p">:</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Zmin&quot;</span><span class="p">:</span> <span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="s2">&quot;Zmax&quot;</span><span class="p">:</span> <span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="s2">&quot;Zmid&quot;</span><span class="p">:</span> <span class="s2">&quot;z&quot;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">surfaceName</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">surface_map</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Surface &#39;</span><span class="si">{</span><span class="n">surfaceName</span><span class="si">}</span><span class="s2">&#39; is not valid. Choose from &#39;Xmin&#39;, &#39;Xmax&#39;, &#39;Ymin&#39;, &#39;Ymax&#39;, &#39;Zmin&#39;, &#39;Zmax&#39;, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;Xmid&#39;, &#39;Ymid&#39;, &#39;Zmid&#39;.&quot;</span><span class="p">)</span>

        <span class="n">surface_value</span> <span class="o">=</span> <span class="n">surface_map</span><span class="p">[</span><span class="n">surfaceName</span><span class="p">]</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">coord_index</span><span class="p">[</span><span class="n">surfaceName</span><span class="p">]</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">({</span>
            <span class="n">point</span> <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">beams</span>
            <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span> <span class="o">==</span> <span class="n">surface_value</span>
        <span class="p">})</span></div>


<div class="viewcode-block" id="Cell.getNodeOrderToSimulate">
<a class="viewcode-back" href="../../src.html#src.Cell.Cell.getNodeOrderToSimulate">[docs]</a>
    <span class="k">def</span> <span class="nf">getNodeOrderToSimulate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the order of nodes to simulate in the cell</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tag_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">tag</span><span class="p">:</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">originalTags</span><span class="p">}</span>

        <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">beam</span><span class="o">.</span><span class="n">radius</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">point</span><span class="o">.</span><span class="n">indexBoundary</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">tag</span> <span class="o">=</span> <span class="n">point</span><span class="o">.</span><span class="n">localTag</span>
                        <span class="k">if</span> <span class="n">tag</span><span class="p">:</span>  <span class="c1"># Ensure tags is not an empty list</span>
                            <span class="k">if</span> <span class="n">tag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">originalTags</span><span class="p">:</span>
                                <span class="n">tag_dict</span><span class="p">[</span><span class="n">tag</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">point</span>
        <span class="k">return</span> <span class="n">tag_dict</span></div>


<div class="viewcode-block" id="Cell.getNodesOrderNN">
<a class="viewcode-back" href="../../src.html#src.Cell.Cell.getNodesOrderNN">[docs]</a>
    <span class="k">def</span> <span class="nf">getNodesOrderNN</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodeInOrder</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">numberRadiusNN</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the nodes order for the neural network</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        nodeInOrder: dict</span>
<span class="sd">            Dictionary of nodes in order</span>
<span class="sd">        originalCellGeom: list</span>
<span class="sd">            Original cell geometry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tag_dictNN</span> <span class="o">=</span> <span class="n">nodeInOrder</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">nodeInOrder</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span><span class="p">:</span>
                <span class="n">tag_dictNN</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="c1"># elif self.originalCellGeom[idx] &lt; numberRadiusNN:</span>
            <span class="c1">#     tag_dictNN[i] = 1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tag_dictNN</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">tag_dictNN</span></div>


<div class="viewcode-block" id="Cell.setDisplacementAtBoundaryNodes">
<a class="viewcode-back" href="../../src.html#src.Cell.Cell.setDisplacementAtBoundaryNodes">[docs]</a>
    <span class="k">def</span> <span class="nf">setDisplacementAtBoundaryNodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">displacementArray</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">displacementIndex</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">printLevel</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set displacement at nodes.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        ------------</span>
<span class="sd">        displacementArray: list or array-like</span>
<span class="sd">            Flattened array of displacement values.</span>
<span class="sd">        displacementIndex: array of int</span>
<span class="sd">            Boundary node index of each displacement value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">printLevel</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Displacement array&quot;</span><span class="p">,</span> <span class="n">displacementArray</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Displacement index&quot;</span><span class="p">,</span> <span class="n">displacementIndex</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Non-zero displacements:&quot;</span><span class="p">,</span> <span class="n">displacementArray</span><span class="p">[</span><span class="n">displacementArray</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">point</span><span class="o">.</span><span class="n">indexBoundary</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">point</span><span class="o">.</span><span class="n">indexBoundary</span> <span class="ow">in</span> <span class="n">displacementIndex</span><span class="p">:</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="n">displacementIndex</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">indexBoundary</span><span class="p">)</span>
                    <span class="n">indexActual</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">point</span><span class="o">.</span><span class="n">fixedDOF</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Filter out the fixed DOF</span>
                            <span class="n">point</span><span class="o">.</span><span class="n">displacementValue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">displacementArray</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="n">indexActual</span><span class="p">]</span>
                            <span class="n">indexActual</span> <span class="o">+=</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="Cell.getDisplacementAtNodes">
<a class="viewcode-back" href="../../src.html#src.Cell.Cell.getDisplacementAtNodes">[docs]</a>
    <span class="k">def</span> <span class="nf">getDisplacementAtNodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodeList</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">numberRadiusNN</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the displacement at nodes.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        nodeList: list of Point objects</span>
<span class="sd">            List of nodes to get the displacement.</span>
<span class="sd">        numberRadiusNN: int</span>
<span class="sd">            Number of radius for the neural network</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        list</span>
<span class="sd">            A flattened list of displacement values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nodeListNN</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNodesOrderNN</span><span class="p">(</span><span class="n">nodeList</span><span class="p">,</span> <span class="n">numberRadiusNN</span><span class="p">)</span>

        <span class="n">displacementList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nullDisplacement</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodeList</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">:</span>
                <span class="n">displacement</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">displacementValue</span>
                <span class="n">displacementList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">displacement</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">nodeListNN</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">displacementList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nullDisplacement</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">displacementList</span></div>


<div class="viewcode-block" id="Cell.setReactionForceOnEachNodes">
<a class="viewcode-back" href="../../src.html#src.Cell.Cell.setReactionForceOnEachNodes">[docs]</a>
    <span class="k">def</span> <span class="nf">setReactionForceOnEachNodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodeList</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">reactionForce</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set reaction force on each node.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        nodeList: dict</span>
<span class="sd">            Dictionary mapping node tags to Point objects.</span>
<span class="sd">        reactionForce: list</span>
<span class="sd">            List of reaction force values corresponding to the nodes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Vrification que la longueur des listes correspond</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">([</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">nodeList</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">reactionForce</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Lenght nodeList &quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">([</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">nodeList</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">])</span>
                  <span class="p">,</span> <span class="s2">&quot;Lenght reactionForce &quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">reactionForce</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;nodeList&quot;</span><span class="p">,</span> <span class="n">nodeList</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;reactionForce&quot;</span><span class="p">,</span> <span class="n">reactionForce</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Mismatch: nodeList and reactionForce must have the same length.&quot;</span><span class="p">)</span>

        <span class="c1"># for beam in self.beams:</span>
        <span class="c1">#     for point in [beam.point1, beam.point2]:</span>
        <span class="c1">#         if point.indexBoundary is not None:</span>
        <span class="c1">#             index = list(nodeList.keys()).index(point.localTag[0])</span>
        <span class="c1">#             point.setReactionForce(reactionForce[index])</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodeList</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nodeList</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                <span class="n">nodeList</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">.</span><span class="n">setReactionForce</span><span class="p">(</span><span class="n">reactionForce</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
                <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="Cell.getNumberOfBoundaryNodes">
<a class="viewcode-back" href="../../src.html#src.Cell.Cell.getNumberOfBoundaryNodes">[docs]</a>
    <span class="k">def</span> <span class="nf">getNumberOfBoundaryNodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of boundary nodes in the cell</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span>
            <span class="p">[</span><span class="n">beam</span> <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">beams</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]</span> <span class="k">if</span> <span class="n">point</span><span class="o">.</span><span class="n">indexBoundary</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">])</span></div>


<div class="viewcode-block" id="Cell.buildCouplingOperator">
<a class="viewcode-back" href="../../src.html#src.Cell.Cell.buildCouplingOperator">[docs]</a>
    <span class="k">def</span> <span class="nf">buildCouplingOperator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nbFreeDOF</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build the coupling operator for the cell</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        nbFreeDOF: int</span>
<span class="sd">            Number of free degrees of freedom</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">listBndNodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">point</span><span class="o">.</span><span class="n">indexBoundary</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">point</span><span class="o">.</span><span class="n">indexBoundary</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">listBndNodes</span><span class="p">:</span>
                    <span class="n">localNodeIndex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">originalTags</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">localTag</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">listBndNodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">indexBoundary</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">point</span><span class="o">.</span><span class="n">globalFreeDOFIndex</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                            <span class="n">col</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">localNodeIndex</span> <span class="o">*</span> <span class="mi">6</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span>
                            <span class="n">row</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">globalFreeDOFIndex</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">nbBndDOFloc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">listBndNodes</span><span class="p">)</span> <span class="o">*</span> <span class="mi">6</span>
        <span class="n">shapeB</span> <span class="o">=</span> <span class="p">(</span><span class="n">nbFreeDOF</span><span class="p">,</span> <span class="n">nbBndDOFloc</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matB</span> <span class="o">=</span> <span class="n">coo_matrix</span><span class="p">((</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)),</span> <span class="n">shape</span><span class="o">=</span><span class="n">shapeB</span><span class="p">)</span></div>


<div class="viewcode-block" id="Cell.buildPreconditioner">
<a class="viewcode-back" href="../../src.html#src.Cell.Cell.buildPreconditioner">[docs]</a>
    <span class="k">def</span> <span class="nf">buildPreconditioner</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SchurMatrix</span><span class="p">:</span> <span class="s2">&quot;coo_matrix&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;coo_matrix&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build the preconditioner part for the cell</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        SchurMatrix: coo_matrix</span>
<span class="sd">            Schur matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">matB</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Coupling matrix has not been built yet. Please build it first.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">matB</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">SchurMatrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Shape of B matrix&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">matB</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Shape of Schur matrix&quot;</span><span class="p">,</span> <span class="n">SchurMatrix</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Incompatible dimensions between the coupling matrix and the Schur matrix.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">matB</span> <span class="o">@</span> <span class="n">SchurMatrix</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">matB</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span></div>


<div class="viewcode-block" id="Cell.getInternalEnergy">
<a class="viewcode-back" href="../../src.html#src.Cell.Cell.getInternalEnergy">[docs]</a>
    <span class="k">def</span> <span class="nf">getInternalEnergy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the internal energy of the cell</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">internalEnergy</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">point</span><span class="o">.</span><span class="n">indexBoundary</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">pointEnergy</span> <span class="o">=</span> <span class="n">point</span><span class="o">.</span><span class="n">calculatePointEnergy</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">pointEnergy</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Negative energy detected at point with index &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">indexBoundary</span><span class="p">))</span>
                    <span class="n">internalEnergy</span> <span class="o">+=</span> <span class="n">pointEnergy</span>
        <span class="k">return</span> <span class="n">internalEnergy</span></div>


<div class="viewcode-block" id="Cell.getDisplacementData">
<a class="viewcode-back" href="../../src.html#src.Cell.Cell.getDisplacementData">[docs]</a>
    <span class="k">def</span> <span class="nf">getDisplacementData</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build and return displacement data on cell for dataset generation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">allBoundaryDisplacementData</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">point</span><span class="o">.</span><span class="n">indexBoundary</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">allBoundaryDisplacementData</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">displacementValue</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">allBoundaryDisplacementData</span></div>


<div class="viewcode-block" id="Cell.changeBeamRadius">
<a class="viewcode-back" href="../../src.html#src.Cell.Cell.changeBeamRadius">[docs]</a>
    <span class="k">def</span> <span class="nf">changeBeamRadius</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newRadius</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">gradRadius</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        ATTENTION: BEAM MOD IS NOT WORKING</span>
<span class="sd">        Change beam radius in the cell</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        newRadius: list</span>
<span class="sd">            beam radius wanted to assign</span>
<span class="sd">        hybridData: list</span>
<span class="sd">            Hybrid data type</span>
<span class="sd">        gradRadius: list</span>
<span class="sd">            Gradient of the radius</span>
<span class="sd">        penalizationCoeff: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">Fore</span><span class="o">.</span><span class="n">RED</span> <span class="o">+</span> <span class="s2">&quot;WARNING: Beam modification is not implemented yet. &quot;</span> <span class="o">+</span> <span class="n">Style</span><span class="o">.</span><span class="n">RESET_ALL</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">newRadius</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;Length of new radius vector and already cell radius vector needs &quot;</span>
                                                    <span class="s2">&quot;to be equal &quot;</span><span class="p">)</span>
        <span class="n">beamRadius</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">rad</span> <span class="ow">in</span> <span class="n">newRadius</span><span class="p">:</span>
            <span class="n">beamRadius</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getBeamRadius</span><span class="p">(</span><span class="n">gradRadius</span><span class="p">,</span> <span class="n">rad</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">beam</span><span class="o">.</span><span class="n">modBeam</span><span class="p">:</span>
                <span class="n">beam</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">beamRadius</span><span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">type</span><span class="p">]</span> <span class="o">*</span> <span class="n">beam</span><span class="o">.</span><span class="n">penalizationCoefficient</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">beam</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">beamRadius</span><span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">type</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">newRadius</span></div>


<div class="viewcode-block" id="Cell.getVolumeCell">
<a class="viewcode-back" href="../../src.html#src.Cell.Cell.getVolumeCell">[docs]</a>
    <span class="k">def</span> <span class="nf">getVolumeCell</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the volume of the cell</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellSize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellSize</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellSize</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span></div>


<div class="viewcode-block" id="Cell.getRelativeDensityCell">
<a class="viewcode-back" href="../../src.html#src.Cell.Cell.getRelativeDensityCell">[docs]</a>
    <span class="k">def</span> <span class="nf">getRelativeDensityCell</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the relative density of the cell</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">volumeBeams</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
            <span class="n">volumeBeams</span> <span class="o">+=</span> <span class="n">beam</span><span class="o">.</span><span class="n">getVolume</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">volumeBeams</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">getVolumeCell</span><span class="p">()</span></div>


<div class="viewcode-block" id="Cell.getVolumeGeomSeparated">
<a class="viewcode-back" href="../../src.html#src.Cell.Cell.getVolumeGeomSeparated">[docs]</a>
    <span class="k">def</span> <span class="nf">getVolumeGeomSeparated</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the volume of the cell separated by geometry type</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">volumes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">beam</span><span class="o">.</span><span class="n">modBeam</span><span class="p">:</span>
                <span class="n">volumeBeam</span> <span class="o">=</span> <span class="n">beam</span><span class="o">.</span><span class="n">getVolume</span><span class="p">()</span>
                <span class="n">volumes</span><span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">type</span><span class="p">]</span> <span class="o">+=</span> <span class="n">volumeBeam</span>
        <span class="k">return</span> <span class="n">volumes</span></div>


<div class="viewcode-block" id="Cell.getRelativeDensityKriging">
<a class="viewcode-back" href="../../src.html#src.Cell.Cell.getRelativeDensityKriging">[docs]</a>
    <span class="k">def</span> <span class="nf">getRelativeDensityKriging</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">krigingModel</span><span class="p">,</span> <span class="n">geomScheme</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the relative density of the cell using kriging model</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        krigingModel: Kriging</span>
<span class="sd">            Kriging model to use for prediction</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">radii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">geomScheme</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">true_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">geomScheme</span><span class="p">)</span> <span class="k">if</span> <span class="n">val</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">true_indices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">):</span>
                <span class="n">radii</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">rad</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">):</span>
                <span class="n">radii</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">rad</span>
        <span class="n">radii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">radii</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">relativeDensity</span> <span class="o">=</span> <span class="n">krigingModel</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">radii</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">relativeDensity</span></div>


<div class="viewcode-block" id="Cell.getRelativeDensityGradient">
<a class="viewcode-back" href="../../src.html#src.Cell.Cell.getRelativeDensityGradient">[docs]</a>
    <span class="k">def</span> <span class="nf">getRelativeDensityGradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">relativeDensityPolyDeriv</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the gradient of the relative density</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        relativeDensityPolyDeriv: list</span>
<span class="sd">            List of polynomial derivative functions</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        deriv: float</span>
<span class="sd">            Derivative of the relative density</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">deriv</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">polyDeriv</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">relativeDensityPolyDeriv</span><span class="p">):</span>
            <span class="n">deriv</span> <span class="o">+=</span> <span class="n">polyDeriv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">deriv</span></div>


<div class="viewcode-block" id="Cell.getRelativeDensityGradientKrigingCell">
<a class="viewcode-back" href="../../src.html#src.Cell.Cell.getRelativeDensityGradientKrigingCell">[docs]</a>
    <span class="k">def</span> <span class="nf">getRelativeDensityGradientKrigingCell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gpr</span><span class="p">,</span> <span class="n">geomScheme</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retourne le gradient de la fonction volume par rapport aux rayons (drive partielle).</span>

<span class="sd">        Paramtres :</span>
<span class="sd">        ------------</span>
<span class="sd">        gpr : GaussianProcessRegressor</span>
<span class="sd">            Modle de Kriging entran.</span>
<span class="sd">        radii : np.ndarray</span>
<span class="sd">            Tableau de taille (n_samples, 3) contenant les rayons.</span>

<span class="sd">        Retourne :</span>
<span class="sd">        ----------</span>
<span class="sd">        gradients : np.ndarray</span>
<span class="sd">            Gradient du volume par rapport aux rayons (shape: (n_samples, 3)).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">1e-3</span>
        <span class="n">radii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">geomScheme</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">true_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">geomScheme</span><span class="p">)</span> <span class="k">if</span> <span class="n">val</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">true_indices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">):</span>
                <span class="n">radii</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">rad</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">):</span>
                <span class="n">radii</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">rad</span>
        <span class="n">radii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">radii</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">grad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">rad</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">grad</span><span class="p">):</span>
            <span class="n">perturbed_radii</span> <span class="o">=</span> <span class="n">radii</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">perturbed_radii</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">epsilon</span>
            <span class="n">grad</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">gpr</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">perturbed_radii</span><span class="p">)</span> <span class="o">-</span> <span class="n">gpr</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">radii</span><span class="p">))</span> <span class="o">/</span> <span class="n">epsilon</span>
        <span class="k">return</span> <span class="n">grad</span></div>


<div class="viewcode-block" id="Cell.getNumberNodesAtBoundary">
<a class="viewcode-back" href="../../src.html#src.Cell.Cell.getNumberNodesAtBoundary">[docs]</a>
    <span class="k">def</span> <span class="nf">getNumberNodesAtBoundary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of nodes at the boundary</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        int</span>
<span class="sd">            Number of nodes at the boundary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">counterNodes</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">nodeAlreadyCounted</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">point</span><span class="o">.</span><span class="n">indexBoundary</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">point</span><span class="o">.</span><span class="n">indexBoundary</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nodeAlreadyCounted</span><span class="p">:</span>
                    <span class="n">counterNodes</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">nodeAlreadyCounted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">indexBoundary</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">counterNodes</span></div>


<div class="viewcode-block" id="Cell.getCellBoundaryBox">
<a class="viewcode-back" href="../../src.html#src.Cell.Cell.getCellBoundaryBox">[docs]</a>
    <span class="k">def</span> <span class="nf">getCellBoundaryBox</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the boundary box of the cell</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        list</span>
<span class="sd">            List of the boundary box coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xMin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinateCell</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">xMax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinateCell</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellSize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">yMin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinateCell</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">yMax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinateCell</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellSize</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">zMin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinateCell</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">zMax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinateCell</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellSize</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">xMin</span><span class="p">,</span> <span class="n">xMax</span><span class="p">,</span> <span class="n">yMin</span><span class="p">,</span> <span class="n">yMax</span><span class="p">,</span> <span class="n">zMin</span><span class="p">,</span> <span class="n">zMax</span><span class="p">]</span></div>


<div class="viewcode-block" id="Cell.getRGBcolorDependingOfRadius">
<a class="viewcode-back" href="../../src.html#src.Cell.Cell.getRGBcolorDependingOfRadius">[docs]</a>
    <span class="k">def</span> <span class="nf">getRGBcolorDependingOfRadius</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the RGB color of the cell depending on the radius.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">r</span> <span class="o">/</span> <span class="mf">0.1</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">)</span></div>


<div class="viewcode-block" id="Cell.getCellCornerCoordinates">
<a class="viewcode-back" href="../../src.html#src.Cell.Cell.getCellCornerCoordinates">[docs]</a>
    <span class="k">def</span> <span class="nf">getCellCornerCoordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the corner coordinates of the cell.</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        list of tuples</span>
<span class="sd">            List of (x, y, z) coordinates of the corner points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">z0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinateCell</span>
        <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">dz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellSize</span>

        <span class="n">corners</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">z0</span><span class="p">),</span>
            <span class="p">(</span><span class="n">x0</span> <span class="o">+</span> <span class="n">dx</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">z0</span><span class="p">),</span>
            <span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span> <span class="o">+</span> <span class="n">dy</span><span class="p">,</span> <span class="n">z0</span><span class="p">),</span>
            <span class="p">(</span><span class="n">x0</span> <span class="o">+</span> <span class="n">dx</span><span class="p">,</span> <span class="n">y0</span> <span class="o">+</span> <span class="n">dy</span><span class="p">,</span> <span class="n">z0</span><span class="p">),</span>
            <span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">z0</span> <span class="o">+</span> <span class="n">dz</span><span class="p">),</span>
            <span class="p">(</span><span class="n">x0</span> <span class="o">+</span> <span class="n">dx</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">z0</span> <span class="o">+</span> <span class="n">dz</span><span class="p">),</span>
            <span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span> <span class="o">+</span> <span class="n">dy</span><span class="p">,</span> <span class="n">z0</span> <span class="o">+</span> <span class="n">dz</span><span class="p">),</span>
            <span class="p">(</span><span class="n">x0</span> <span class="o">+</span> <span class="n">dx</span><span class="p">,</span> <span class="n">y0</span> <span class="o">+</span> <span class="n">dy</span><span class="p">,</span> <span class="n">z0</span> <span class="o">+</span> <span class="n">dz</span><span class="p">),</span>
        <span class="p">]</span>

        <span class="k">return</span> <span class="n">corners</span></div>


<div class="viewcode-block" id="Cell.addCellNeighbour">
<a class="viewcode-back" href="../../src.html#src.Cell.Cell.addCellNeighbour">[docs]</a>
    <span class="k">def</span> <span class="nf">addCellNeighbour</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">neighbourCell</span><span class="p">:</span> <span class="s2">&quot;Cell&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a neighbour cell to the current cell if it&#39;s not already present.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        neighbourCell: Cell</span>
<span class="sd">            Neighbour cell to add</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">neighbourCell</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighbourCells</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">neighbourCells</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbourCell</span><span class="p">)</span></div>


<div class="viewcode-block" id="Cell.printCellData">
<a class="viewcode-back" href="../../src.html#src.Cell.Cell.printCellData">[docs]</a>
    <span class="k">def</span> <span class="nf">printCellData</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print the data of the cell for debugging purposes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cell position: &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">posCell</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cell coordinates: &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinateCell</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cell size: &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellSize</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Lattice type: &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom_types</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Beam radius: &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Beam material: &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_beamMaterial</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Beams in cell: &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">beams</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cell center point: &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">centerPoint</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cell index: &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Beam material: &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_beamMaterial</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Coupling matrix: &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">matB</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of beams: &quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beams</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Volume of the cell: &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">getVolumeCell</span><span class="p">())</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Relative density: &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">getRelativeDensityCell</span><span class="p">())</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of nodes at boundary: &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumberNodesAtBoundary</span><span class="p">())</span></div>


<div class="viewcode-block" id="Cell.getTranslationRigidBody">
<a class="viewcode-back" href="../../src.html#src.Cell.Cell.getTranslationRigidBody">[docs]</a>
    <span class="k">def</span> <span class="nf">getTranslationRigidBody</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the translation of the rigid body</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">translation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">beam</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">beams</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">point1</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">point2</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">point</span><span class="o">.</span><span class="n">indexBoundary</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">translation</span> <span class="o">+=</span> <span class="n">point</span><span class="o">.</span><span class="n">displacementValue</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">translation</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumberNodesAtBoundary</span><span class="p">()</span></div>


<div class="viewcode-block" id="Cell.getRotationRigidBody">
<a class="viewcode-back" href="../../src.html#src.Cell.Cell.getRotationRigidBody">[docs]</a>
    <span class="k">def</span> <span class="nf">getRotationRigidBody</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the rotation matrix of the rigid body using SVD.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">all_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAllPoints</span><span class="p">()</span>
        <span class="n">initial_positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">point</span><span class="o">.</span><span class="n">getPos</span><span class="p">()</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">all_points</span><span class="p">])</span>  <span class="c1"># P_i</span>
        <span class="n">final_positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">point</span><span class="o">.</span><span class="n">getDeformedPos</span><span class="p">()</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">all_points</span><span class="p">])</span>  <span class="c1"># P_i&#39;</span>

        <span class="c1"># Soustraction du centre de gravit</span>
        <span class="n">center_initial</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">initial_positions</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">center_final</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">final_positions</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">initial_positions</span> <span class="o">-</span> <span class="n">center_initial</span>
        <span class="n">P_prime</span> <span class="o">=</span> <span class="n">final_positions</span> <span class="o">-</span> <span class="n">center_final</span>

        <span class="c1"># Matrice de covariance</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">P_prime</span>

        <span class="c1"># Dcomposition SVD</span>
        <span class="n">U</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">Vt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">Vt</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">U</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Correction si ncessaire (assurer que R est une rotation propre)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">Vt</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">Vt</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">U</span><span class="o">.</span><span class="n">T</span>

        <span class="k">return</span> <span class="n">R</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Thomas Cadart.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>